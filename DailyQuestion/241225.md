# 오늘의 질문

def solution(number, k):
    stack = []  # 스택은 선택한 숫자를 저장할 리스트입니다.

    for num in number:  # 주어진 숫자 문자열의 각 문자에 대해 반복
        while stack and k > 0 and num > stack[-1]:
            stack.pop()
            k -= 1
        stack.append(num)

    if k > 0:
        stack = stack[:-k]

    return ''.join(stack)

# 스택 동작 설명:
스택은 선택된 숫자들을 임시로 저장하여 최종적으로 가장 큰 숫자를 만드는데 사용됩니다.
현재 숫자가 스택의 마지막 요소보다 크고, 제거 가능한 숫자가 남아있으면 스택의 마지막 요소를 제거합니다.
예를 들어:
- 숫자 "1924"에서 k = 2인 경우:
  1. '1' 추가 → 스택: ['1']
  2. '9' 추가 → '1' 제거 후 '9' 추가 → 스택: ['9']
  3. '2' 추가 → 스택: ['9', '2']
  4. '4' 추가 → '2' 제거 후 '4' 추가 → 스택: ['9', '4']

# 슬라이싱 동작 설명:
`stack[:-k]`는 리스트의 뒤에서 k개의 요소를 제거합니다.
예:
- 스택: ['1', '2', '3', '4']
- 슬라이싱: stack[:-2] → ['1', '2']
이를 통해 제거되지 않은 숫자들만 남길 수 있습니다.

# join() 메서드 설명:
스택에 저장된 문자들을 하나의 문자열로 합칩니다.
예:
- 스택: ['7', '7', '5', '8', '4', '1']
- 결과: ''.join(stack) → "775841"

# 예제 테스트 시나리오:
- 숫자가 내림차순: "54321", k = 2 → 결과: "543"
- 숫자가 랜덤: "1924", k = 2 → 결과: "94"
- 숫자가 오름차순: "123456", k = 3 → 결과: "456"
- 숫자가 반복: "4177252841", k = 4 → 결과: "775841"

# 시간 복잡도:
입력 문자열의 길이를 N이라 할 때:
- 반복문: 각 숫자는 스택에 한 번 추가되고, 최대 k번 제거 → O(N)
- 슬라이싱: O(k)
따라서 전체 시간 복잡도는 O(N)입니다.
