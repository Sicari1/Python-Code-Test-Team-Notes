# 오늘의 질문

def solution(number, k):
    stack = []  # 스택은 선택한 숫자를 저장할 리스트입니다.

    for num in number:  # 주어진 숫자 문자열의 각 문자에 대해 반복
        # 현재 숫자(num)가 스택의 마지막 요소보다 크고, 제거 가능한 숫자(k)가 남아 있으면
        while stack and k > 0 and num > stack[-1]:
            stack.pop()  # 스택의 마지막 숫자를 제거
            k -= 1  # 제거 가능한 숫자 개수를 줄임

        stack.append(num)  # 현재 숫자를 스택에 추가

    # 모든 숫자를 확인했는데 제거 가능한 숫자가 남아 있다면
    if k > 0:
        # 스택의 뒤에서 k개의 요소를 제거 (슬라이싱)
        stack = stack[:-k]

    # 스택의 모든 요소를 합쳐 최종 문자열 반환
    answer = ''.join(stack)
    return answer

# 1. `stack.pop()`의 동작과 확장:
# pop()은 리스트에서 마지막 요소를 제거하며 그 값을 반환합니다.
# 특정 인덱스에서 제거하고 싶다면 pop(index)를 사용합니다.
# 예:
stack = [1, 2, 3]
print(stack.pop())  # 출력: 3, stack은 [1, 2]로 변경
stack = [1, 2, 3]
print(stack.pop(1))  # 출력: 2, stack은 [1, 3]로 변경

# 2. `stack[:-k]`의 동작:
# 슬라이싱 문법을 사용해 리스트의 뒤에서 k개를 제거합니다.
# 기본 문법: `list[start:end:step]`에서 start는 시작 인덱스, end는 끝 인덱스, step은 간격을 의미합니다.
# 음수 인덱스는 리스트의 끝에서부터 접근할 때 사용됩니다.
# 예:
stack = ['1', '2', '3', '4']
print(stack[:-2])  # 출력: ['1', '2']

# 예제: 슬라이싱 사용 예시
lst = [10, 20, 30, 40, 50]
print(lst[:-1])  # [10, 20, 30, 40]
print(lst[-3:])  # [30, 40, 50]

# 3. `''.join(stack)`:
# 리스트에 있는 문자열을 하나의 문자열로 결합합니다.
# 예:
stack = ['1', '2', '3']
print(''.join(stack))  # 출력: "123"

# 4. 여러 시나리오를 통한 동작 확인:

# 시나리오 1: 숫자가 내림차순으로 정렬되어 있는 경우
number = "54321"
k = 2
# 제거된 숫자: "5", "4" (내림차순이므로 아무도 pop되지 않음)
print(solution(number, k))  # 출력: "543"

# 시나리오 2: 숫자가 랜덤하게 배치된 경우
number = "1924"
k = 2
# 스택 동작: [1], [1, 9], [9], [9, 2], [9, 4]
# 제거된 숫자: "1", "2" -> 최종 결과: "94"
print(solution(number, k))  # 출력: "94"

# 시나리오 3: 숫자가 오름차순으로 정렬된 경우
number = "123456"
k = 3
# 제거된 숫자: "1", "2", "3"
print(solution(number, k))  # 출력: "456"

# 시나리오 4: 중간에 같은 숫자가 반복되는 경우
number = "4177252841"
k = 4
# 스택 동작: [4], [4, 1], [4, 7], [7], [7, 7], [7, 7, 2], [7, 7, 5], [7, 8], [8, 4], [8, 1]
# 제거된 숫자: "4", "1", "7", "2" -> 최종 결과: "775841"
print(solution(number, k))  # 출력: "775841"

# 추가 개념 설명:
# 1. 스택 활용 이유:
#    - 내림차순으로 정렬된 숫자열에서 최대 숫자를 빠르게 선택할 수 있음.
#    - 현재 숫자가 스택의 마지막 숫자보다 크면, 현재 숫자를 스택에 추가하기 전 스택의 마지막 숫자를 제거하여 더 큰 숫자를 선택할 수 있도록 함.

# 2. 시간복잡도:
#    - `number`의 길이가 N일 때, 최악의 경우 모든 숫자를 한 번씩 확인하고, k번 pop()을 실행하므로 O(N) 시간복잡도를 가집니다.

# 3. 슬라이싱 동작 최적화:
#    - `stack[:-k]`의 슬라이싱은 O(k)에 해당하며, 리스트에서 뒤쪽 데이터를 잘라내는 효율적인 방법입니다.
