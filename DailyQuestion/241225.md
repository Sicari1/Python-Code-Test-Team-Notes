# 오늘의 질문

def solution(number, k):
    stack = []  # 스택은 선택한 숫자를 저장할 리스트입니다.

    for num in number:  # 주어진 숫자 문자열의 각 문자에 대해 반복
        while stack and k > 0 and num > stack[-1]:
            stack.pop()
            k -= 1
        stack.append(num)

    if k > 0:
        stack = stack[:-k]

    return ''.join(stack)

# 스택 동작 설명:
스택은 선택된 숫자들을 임시로 저장하여 최종적으로 가장 큰 숫자를 만드는데 사용됩니다.
현재 숫자가 스택의 마지막 요소보다 크고, 제거 가능한 숫자가 남아있으면 스택의 마지막 요소를 제거합니다.
예를 들어:
- 숫자 "1924"에서 k = 2인 경우:
  1. '1' 추가 → 스택: ['1']
  2. '9' 추가 → '1' 제거 후 '9' 추가 → 스택: ['9']
  3. '2' 추가 → 스택: ['9', '2']
  4. '4' 추가 → '2' 제거 후 '4' 추가 → 스택: ['9', '4']

# 슬라이싱 동작 설명:
`stack[:-k]`는 리스트의 뒤에서 k개의 요소를 제거합니다.
예:
- 스택: ['1', '2', '3', '4']
- 슬라이싱: stack[:-2] → ['1', '2']
이를 통해 제거되지 않은 숫자들만 남길 수 있습니다.

# join() 메서드 설명:
스택에 저장된 문자들을 하나의 문자열로 합칩니다.
예:
- 스택: ['7', '7', '5', '8', '4', '1']
- 결과: ''.join(stack) → "775841"

# 예제 테스트 시나리오:
- 숫자가 내림차순: "54321", k = 2 → 결과: "543"
- 숫자가 랜덤: "1924", k = 2 → 결과: "94"
- 숫자가 오름차순: "123456", k = 3 → 결과: "456"
- 숫자가 반복: "4177252841", k = 4 → 결과: "775841"

# 시간 복잡도:
입력 문자열의 길이를 N이라 할 때:
- 반복문: 각 숫자는 스택에 한 번 추가되고, 최대 k번 제거 → O(N)
- 슬라이싱: O(k)
따라서 전체 시간 복잡도는 O(N)입니다.



# pop() 메서드에 대한 추가 설명:

## 1. 기본 동작
pop() 메서드는 리스트의 마지막 요소를 제거하고 그 값을 반환합니다.
기본 문법: `list.pop(index)`  
- index를 지정하지 않으면, 리스트의 **마지막 요소**를 제거합니다.
- index를 지정하면 해당 위치의 요소를 제거합니다.
예:
stack = [1, 2, 3]
last_element = stack.pop()  # 3 제거, stack = [1, 2]
print(last_element)  # 출력: 3
second_element = stack.pop(1)  # 2 제거, stack = [1]
print(second_element)  # 출력: 2

## 2. 인덱스 지정 제거
pop(index)를 사용하면 리스트의 특정 위치에 있는 요소를 제거할 수 있습니다.
예:
stack = [10, 20, 30, 40]
removed = stack.pop(2)  # 인덱스 2에 있는 30 제거
print(removed)  # 출력: 30
print(stack)  # 출력: [10, 20, 40]

## 3. pop()과 빈 리스트
리스트가 비어 있을 때 pop()을 호출하면 `IndexError`가 발생합니다.
예:
stack = []
# stack.pop()  # IndexError: pop from empty list

## 4. pop()과 효율성
pop() 메서드는 리스트의 끝에서 요소를 제거하는 경우 **O(1)** 시간 복잡도를 가집니다.  
하지만 리스트의 앞쪽 요소를 제거하면 나머지 요소들이 앞으로 이동해야 하므로 **O(N)** 시간 복잡도가 됩니다.

## 5. pop()의 활용
- **스택 구현:** pop()을 사용하여 스택의 마지막 요소를 제거할 수 있습니다.
- **순회 중 제거:** 반복문에서 특정 조건에 따라 요소를 제거할 수 있습니다.
예:
stack = [1, 3, 5, 7, 9]
while stack and stack[-1] > 5:
    print(stack.pop())  # 출력: 9, 7 (스택에서 제거)

# pop()과 remove() 비교:
- pop(index): 특정 위치의 요소를 제거하며, 제거된 값을 반환.
- remove(value): 리스트에서 첫 번째로 만나는 해당 값을 제거.
예:
lst = [1, 2, 3, 2, 4]
lst.pop(1)  # 2 제거, lst = [1, 3, 2, 4]
lst.remove(2)  # 첫 번째 2 제거, lst = [1, 3, 4]

# pop()과 del 비교:
- pop(): 제거된 값을 반환하며, 지정된 요소만 제거.
- del: 값을 반환하지 않고 여러 요소를 한 번에 제거 가능.
예:
lst = [10, 20, 30, 40]
del lst[1]  # lst = [10, 30, 40]
del lst[1:3]  # lst = [10]
