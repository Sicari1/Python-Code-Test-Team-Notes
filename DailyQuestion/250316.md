
# 🚀 Python BFS 및 다익스트라 알고리즘 문제 해결 정리

## **1️⃣ `heapq` 사용 이유 및 `heap`의 동작 원리**

- **`heapq`는 리스트를 최소 힙(min-heap)처럼 다루는 라이브러리**이며, 다익스트라 알고리즘에서 최단 거리 노드를 빠르게 선택하는 데 사용됨.
- `heapq`를 사용하면 `O(E log N)`의 시간 복잡도를 가지지만, 일반 리스트로 구현하면 `O(N^2)`이 되어 비효율적임.
- `heapq`는 `heapq.heappush(heap, (cost, node))` 형태로 사용해야 함.

✅ **정리**  
- `heap`은 그냥 리스트 변수명일 뿐. `heapq`는 이를 조작하는 라이브러리.  
- `heapq`는 `heapify()`로 리스트를 힙으로 변환할 수도 있음.  
- 다익스트라에서 `heapq.heappop()`을 사용하여 최소 거리 노드를 효율적으로 선택함.

---

## **2️⃣ `deque`의 사용 방식과 `deque((x, y))` vs. `deque([(x, y)])` 차이점**

```python
from collections import deque

queue = deque([(x, y)])  # ✅ 올바른 방식
queue = deque((x, y))  # ❌ 잘못된 방식
```
### 🚨 **왜 `deque([(x, y)])`를 사용해야 하는가?**
- `deque([(x, y)])`: `(x, y)`를 **하나의 튜플 요소로 넣음.** (올바른 방식 ✅)
- `deque((x, y))`: `(x, y)` 튜플을 **반복 가능한 객체로 해석하여 각 요소를 따로 추가함.** (`deque([x, y])`가 되어 BFS에서 오류 발생 ❌)

✅ **정리**  
- **BFS에서는 `(x, y)` 쌍을 유지해야 하므로 `deque([(x, y)])`를 사용해야 함.**  
- **잘못하면 `popleft()` 호출 시 x 값만 나와서 튜플 구조가 깨짐.**  

---

## **3️⃣ `if not (0 <= nx < n and 0 <= ny < m):` vs. `if not 0 <= nx < n and 0 <= ny < m:` 차이**

| 표현 | 동작 방식 | 올바른 예제? |
|------|----------|-------------|
| `if not (0 <= nx < n and 0 <= ny < m):` | **전체 조건을 부정** | ✅ |
| `if not 0 <= nx < n and 0 <= ny < m:` | **nx 범위만 부정하고, ny 범위와 AND 연산** | 🚨 (잘못된 범위 검사) |

🚀 **결론:**  
✅ `if not (0 <= nx < n and 0 <= ny < m):` → **괄호를 포함해서 쓰는 것이 올바른 방식!**

---

## **4️⃣ `is_blocked` 함수의 논리 분석**

```python
def is_blocked(x, y, board, N):
    return (x, y) == (0, 0) or not is_valid(x, y, N) or board[x][y] == 1
```
✅ `True` 반환 (막힘) 조건:
1. `(x, y) == (0, 0)`이면 **출발점이므로 이동 불가**
2. `not is_valid(x, y, N)`이면 **범위를 벗어나 이동 불가**
3. `board[x][y] == 1`이면 **벽이므로 이동 불가**

❌ `False` 반환 (이동 가능) 조건:
- 위 **세 가지 조건이 모두 거짓**일 때.

✅ **결론:**  
- 출발점을 막는 처리는 문제의 요구사항에 따라 달라질 수 있음.  
- `is_valid()` 함수를 사용하여 범위 체크를 먼저 하는 것이 안전함.  

---

## **5️⃣ `calculate_cost()`에서 `prev_direction` 비교 로직**

```python
def calculate_cost(direction, prev_direction, cost):
    if prev_direction == -1 or (prev_direction - direction) % 2 == 0:
        return cost + 100  # ✅ 직진 비용
    else:
        return cost + 600  # ✅ 코너 비용
```
✅ **출발점(`prev_direction == -1`)이면 무조건 `+100` 적용**  
✅ **같은 축(가로 ↔ 가로, 세로 ↔ 세로)이면 `+100` 적용 (직진)**  
✅ **다른 축(가로 ↔ 세로, 세로 ↔ 가로)이면 `+600` 적용 (코너)**  

🚀 **결론:**  
- BFS에서는 `visited` 체크 덕분에 실제로 "되돌아가는 이동"은 발생하지 않음.  
- 다만, **반대 방향 이동(왼쪽 → 오른쪽, 위 → 아래)도 같은 축에서 움직이는 것이므로 "직진"으로 취급**됨.  

---

## **🔥 최종 요약 정리**
1. **다익스트라에서 `heapq`를 사용하는 이유**  
   - `O(N^2)` 대신 `O(E log N)`로 효율적 탐색 가능  
   - `heapq.heappush()`와 `heapq.heappop()`을 이용해 최소 거리 선택  

2. **`deque([(x, y)])`를 사용해야 하는 이유**  
   - `(x, y)`를 **한 개의 요소로 유지해야 하므로 `deque((x, y))`가 아니라 `deque([(x, y)])` 사용**  

3. **범위 검사 시 `if not (조건)`과 `if not 조건 and 조건` 차이**  
   - **괄호를 반드시 사용해야 논리적 오류를 방지할 수 있음.**  

4. **`is_blocked()`에서 이동 불가능한 조건을 확인하는 방식**  
   - 출발점, 범위 초과, 벽(`board[x][y] == 1`) 체크  

5. **`prev_direction`을 비교하는 이유**  
   - 같은 축(가로 ↔ 가로, 세로 ↔ 세로) 이동이면 **직진(`+100`)**
   - 다른 축(가로 ↔ 세로, 세로 ↔ 가로)이면 **코너(`+600`)**

🔥 **이제 BFS, 다익스트라, 방향 비용 계산까지 완벽하게 이해됨!** 🚀  
