# 기능개발 문제 풀이 정리

> **프로그래머스 스택/큐 - 기능개발**

<br />

## 문제 설명

프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 `progresses`와 각 작업의 개발 속도가 적힌 정수 배열 `speeds`가 주어질 때 **각 배포마다 몇 개의 기능이 배포되는지**를 return 하도록 `solution` 함수를 완성하세요.

---

### 제한 사항

- 작업의 개수(`progresses`, `speeds` 배열의 길이)는 100개 이하입니다.
- 작업 진도는 100 미만의 자연수입니다.
- 작업 속도는 100 이하의 자연수입니다.
- 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다.  
  예를 들어, 진도율이 `95%`인 작업의 개발 속도가 하루에 `4%`라면, 배포는 2일 뒤에 이루어집니다.

---

### 입출력 예시

- **예 1**  
  - 입력  
    ```
    progresses = [93, 30, 55]
    speeds     = [1, 30, 5]
    ```  
  - 출력  
    ```
    [2, 1]
    ```
  
  첫 번째 기능은 7일, 두 번째 기능은 3일, 세 번째 기능은 9일이 걸리지만,  
  앞선 기능이 완료되지 않으면 뒤의 기능도 배포할 수 없어서  
  최종적으로 7일째에 2개, 9일째에 1개가 배포된다.

- **예 2**  
  - 입력  
    ```
    progresses = [95, 90, 99, 99, 80, 99]
    speeds     = [1, 1, 1, 1, 1, 1]
    ```  
  - 출력  
    ```
    [1, 3, 2]
    ```
  
  각각 5, 10, 1, 1, 20, 1일이 걸리며,  
  최종적으로 5일째에 1개, 10일째에 3개, 20일째에 2개 배포가 된다.

<br />

---

## 실패한 코드 분석

아래 코드는 **매일** 작업을 조금씩 진행시킨 후, 맨 앞 기능이 100% 이상이면 `popleft()` 하면서 배포 가능한 수를 `answer`에 바로 넣는 방식입니다.

~~~~python
def solution(progresses, speeds):
    answer = []
    from collections import deque
    Q = deque(progresses)
    number = 0
    while Q:
        if Q[0] >= 100:
            Q.popleft()
            number += 1
        else:
            number = 0
            for i in range(len(Q)):
                Q[i] += speeds[i]
        answer.append(number)
    return answer
~~~~

### 왜 틀릴까?

- 배포가 **일어나는 날이 아닌 날**에도 계속 `answer`에 `0`이 들어감.
- 결과적으로 `[0,0,0,0,0,1,0,0,0,0, ...]`처럼 길고 필요 없는 0이 많아짐.
- 문제에서는 “**배포가 일어나는 시점**마다 **몇 개씩**”만 기록하기를 원하는데,  
  매일 단위로 기록해서 오답이 됨.

<br />

---

## 정답 아이디어

1. **각 기능마다 ‘완성까지 남은 일수’를 미리 계산**한다.  
   - `progress = 93`, `speed = 1` → 남은 작업량 7 → **7일**  
2. 이렇게 계산된 일수(`daysNeeded`)를 왼쪽부터 순회한다.  
   - 첫 기능의 필요한 일수를 `current_max`로 둔다.  
   - 다음 기능이 `current_max` 이하의 일수로 완료되면 **같이 배포** (count 증가)  
   - 초과하면 지금까지 count를 `answer`에 넣고, 새롭게 `current_max` 업데이트
3. 마지막에 남은 count도 `answer`에 추가.

### 예시

- `progresses = [93, 30, 55]`, `speeds = [1, 30, 5]`  
- 필요한 일수: `[7, 3, 9]`  
- 순회  
  - `current_max = 7`, `count = 1`  
  - 다음은 3일 → 3 ≤ 7, **같이 배포** → `count = 2`  
  - 다음은 9일 → 9 > 7, **새 배포** → `answer = [2]`, `current_max = 9`, `count = 1`  
- 마지막 count = 1 → `answer = [2, 1]`

<br />

---

## 정답 코드

~~~~python
import math

def solution(progresses, speeds):
    days_needed = []
    # 1) 각 기능별 남은 일수 계산
    for p, s in zip(progresses, speeds):
        remaining = 100 - p
        days = math.ceil(remaining / s)  # 나누어떨어지지 않으면 올림
        days_needed.append(days)

    answer = []
    # 2) 왼쪽부터 순회하며 배포 묶음 구하기
    current_max = days_needed[0]
    count = 1

    for i in range(1, len(days_needed)):
        if days_needed[i] <= current_max:
            count += 1
        else:
            answer.append(count)
            count = 1
            current_max = days_needed[i]

    # 마지막 묶음 처리
    answer.append(count)
    return answer
~~~~

- **시간 복잡도**  
  - 남은 일수 계산: `O(N)`  
  - 배포 묶음 계산: `O(N)`  
  - 전체적으로 **O(N)**  
- **자료구조**  
  - 리스트로 daysNeeded를 만들고, 순서대로 순회하며 배포 묶음을 만든다.  
  - 이 문제에서 큐를 직접적으로 사용할 필요는 없으나,  
    맨 앞 기능부터 순차 처리한다는 점에서는 큐의 개념과 유사하다.

<br />

---

## 스택(Stack)과 큐(Queue)의 차이

### 1) 스택(Stack)
- **후입선출 (LIFO, Last In First Out)**  
- 나중에 들어간 자료가 먼저 나온다.
- 주요 연산: `push()` / `pop()`
- 예: 접시 쌓기 (맨 위 접시부터 꺼낸다)

### 2) 큐(Queue)
- **선입선출 (FIFO, First In First Out)**  
- 먼저 들어간 자료가 먼저 나온다.
- 주요 연산: `enqueue()` / `dequeue()`
- 예: 은행 줄서기 (먼저 줄 선 사람이 먼저 빠져나간다)

> 이번 문제에서는 **작업이 들어온 순서대로** (맨 앞부터) 처리해야 하므로,  
> 큐의 사고방식을 적용하는 경우가 많다.

<br />

---

## 요약

1. **틀린 원인**  
   - 매일 작업 진도를 `answer`에 기록하면서 배포가 일어나지 않는 날에도 `0`을 넣어버림.
2. **정답 아이디어**  
   - 각 기능이 며칠 걸리는지 산출 후, 앞 기능이 완료되는 날에 함께 배포할 수 있는지 판단.  
3. **스택 vs 큐**  
   - **스택**: 후입선출  
   - **큐**: 선입선출  
4. **시간 복잡도**: `O(N)`

이 로직으로 구현하면 문제에서 원하는 `[2, 1]`, `[1, 3, 2]`와 같은  
“**배포마다 몇 개의 기능이 동시에 배포되는지**”를 쉽게 구할 수 있다.
